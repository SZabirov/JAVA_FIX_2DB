# JDBC

Для работы с БД из java-приложения:
1)  Добавляем JDBC Driver к приложению:
    ```xml
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <version>42.2.5</version>
    </dependency>
    ```
2)  Выполняем подключение к базе, передав соответствующий
    url, в котором указываем адрес, порт, имя базы, имя
    пользователя и пароль:
    ```
    String url = "jdbc:postgresql://localhost:5432/shop_db?user=postgres&password=postgres";
    Connection connection = DriverManager.getConnection(url);
    ```
3)  Далее используем `connection` для запросов:
    - `Statement` - применяем только для запросов 
    без параметров, использование с параметрами
    может привести к sql-инъекциям
    - `PreparedStatement` - для прекомпиллированных запросов с параметрами,
    исключает проблему с sql-инъекциями. Эффективен при многократном выполнении запросов.
    
4)  Для `INSERT`, `UPDATE`, `DELETE` и DDL-команд используем 
    `executeUpdate()`, для получения табличных данных в качестве
    ответа используем `executeQuery()`, возвращающий объект `ResultSet`.
    Для построчной обработки `ResultSet` 
    используем `next()`, сдвигающий указатель к
    следующей строке (изначально стоит перед первой строкой), и набор
    getter'ов для получения значений соответствующего типа по названию
    колонки.
    
Типичная структура для работы с данными - объекты-модели (`app.models`) - 
сущности, с которыми работает система, и объекты доступа к данным 
(`app.dao` - data access object).

Паттерн DAO предполагает наличие общего интерфейса, определяющего 
базовый набор CRUD-операций:
```
public interface CrudDao<T> {
    T create(T model);
    T read(Integer id);
    T update(T model);
    void delete(Integer id);
}
```
Данный интерфейс может быть расширен интерфейсами, имеющими 
более специфичный набор операций, относящихся к модели с 
которой они работают. Например, `UserDao` является потомком 
`CrudDao` и дополняет его методом `User findByUsername(String username);`

Такие интерфейсы могут быть реализованы классами, работающими со своим 
специфичным источником данных. Классы бизнес-логики не зависят от 
конкретных реализаций интерфейсов, но зависят от самих интерфейсов.
Таким образом достигается абстракция основных алгоритмов от источника
данных.
